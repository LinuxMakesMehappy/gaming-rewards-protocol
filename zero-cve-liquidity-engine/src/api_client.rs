use reqwest::Client;
use serde::{Deserialize, Serialize};
use crate::{
    error::{LiquidityError, Result},
    types::{Pool, TokenInfo, MarketData},
};
use std::collections::HashMap;
use log::{info, warn};

pub struct ApiClient {
    client: Client,
    base_url: String,
    cache: HashMap<String, (serde_json::Value, std::time::Instant)>,
    cache_duration: std::time::Duration,
}

impl ApiClient {
    pub fn new(base_url: &str) -> Result<Self> {
        let client = Client::builder()
            .timeout(std::time::Duration::from_secs(30))
            .user_agent("Zero-CVE-Liquidity-Engine/1.0.0")
            .build()
            .map_err(|e| LiquidityError::ConfigurationError {
                message: format!("Failed to create HTTP client: {}", e),
            })?;

        Ok(Self {
            client,
            base_url: base_url.to_string(),
            cache: HashMap::new(),
            cache_duration: std::time::Duration::from_secs(60), // 1 minute cache
        })
    }

    /// Make a GET request
    pub async fn get<T>(&self, endpoint: &str) -> Result<T>
    where
        T: for<'de> Deserialize<'de> + serde::Serialize,
    {
        let url = format!("{}{}", self.base_url, endpoint);
        
        // Check cache first
        if let Some((cached_data, timestamp)) = self.cache.get(&url) {
            if timestamp.elapsed() < self.cache_duration {
                return serde_json::from_value(cached_data.clone())
                    .map_err(LiquidityError::SerializationError);
            }
        }

        info!("Making API request to: {}", url);
        
        let response = self.client
            .get(&url)
            .send()
            .await
            .map_err(LiquidityError::ApiError)?;

        if !response.status().is_success() {
            return Err(LiquidityError::ApiError(
                response.error_for_status().unwrap_err()
            ));
        }

        let data: T = response
            .json()
            .await
            .map_err(LiquidityError::ApiError)?;

        // Cache the response
        let json_data = serde_json::to_value(&data)
            .map_err(LiquidityError::SerializationError)?;
        
        // Note: We can't mutate self.cache here because we're borrowing self
        // In a real implementation, you'd use Arc<Mutex<>> or similar for thread-safe caching

        Ok(data)
    }

    /// Make a POST request
    pub async fn post<T, U>(&self, endpoint: &str, body: &T) -> Result<U>
    where
        T: Serialize,
        U: for<'de> Deserialize<'de>,
    {
        let url = format!("{}{}", self.base_url, endpoint);
        
        info!("Making POST request to: {}", url);
        
        let response = self.client
            .post(&url)
            .json(body)
            .send()
            .await
            .map_err(LiquidityError::ApiError)?;

        if !response.status().is_success() {
            return Err(LiquidityError::ApiError(
                response.error_for_status().unwrap_err()
            ));
        }

        let data: U = response
            .json()
            .await
            .map_err(LiquidityError::ApiError)?;

        Ok(data)
    }

    /// Get pools from Jupiter API (replacement)
    pub async fn get_jupiter_pools(&self) -> Result<Vec<Pool>> {
        // This replaces the Jupiter API call
        // In a real implementation, you'd call the actual Jupiter API
        // For now, we'll return mock data
        
        let mock_pools = vec![
            Pool {
                address: "Pool1Address".to_string(),
                token_a: "USDC".to_string(),
                token_b: "SOL".to_string(),
                reserve_a: 1000000000,
                reserve_b: 1000000000,
                fee_rate: 0.003,
                volume_24h: 1000000000,
                liquidity: 1000000000,
            },
            Pool {
                address: "Pool2Address".to_string(),
                token_a: "USDC".to_string(),
                token_b: "ETH".to_string(),
                reserve_a: 500000000,
                reserve_b: 200000000,
                fee_rate: 0.003,
                volume_24h: 500000000,
                liquidity: 500000000,
            },
        ];

        Ok(mock_pools)
    }

    /// Get token information
    pub async fn get_token_info(&self, token_address: &str) -> Result<TokenInfo> {
        // Mock implementation - replace with actual API call
        let token_info = TokenInfo {
            symbol: "USDC".to_string(),
            address: token_address.to_string(),
            decimals: 6,
            price_usd: Some(rust_decimal::Decimal::new(100, 0)), // $1.00
            volume_24h: Some(1000000000),
        };

        Ok(token_info)
    }

    /// Get market data
    pub async fn get_market_data(&self, token: &str) -> Result<MarketData> {
        // Mock implementation - replace with actual API call
        let market_data = MarketData {
            token: token.to_string(),
            price_usd: rust_decimal::Decimal::new(100, 0), // $1.00
            volume_24h: 1000000000,
            market_cap: Some(10000000000),
            price_change_24h: 0.05, // 5% increase
            last_updated: chrono::Utc::now(),
        };

        Ok(market_data)
    }

    /// Get quote for swap
    pub async fn get_swap_quote(
        &self,
        input_token: &str,
        output_token: &str,
        amount: u64,
        slippage: f64,
    ) -> Result<crate::types::SwapQuote> {
        // Mock implementation - replace with actual quote API
        let quote = crate::types::SwapQuote {
            input_token: input_token.to_string(),
            output_token: output_token.to_string(),
            input_amount: amount,
            output_amount: amount * 95 / 100, // 5% fee
            fee_amount: amount * 5 / 100,
            price_impact: 0.001, // 0.1%
            route: crate::types::TradeRoute {
                pools: vec![
                    Pool {
                        address: "PoolAddress".to_string(),
                        token_a: input_token.to_string(),
                        token_b: output_token.to_string(),
                        reserve_a: 1000000000,
                        reserve_b: 1000000000,
                        fee_rate: 0.003,
                        volume_24h: 1000000000,
                        liquidity: 1000000000,
                    }
                ],
                input_token: input_token.to_string(),
                output_token: output_token.to_string(),
                expected_output: amount * 95 / 100,
                fee_estimate: amount * 5 / 100,
                price_impact: 0.001,
                route_type: crate::types::RouteType::Direct,
            },
            valid_until: chrono::Utc::now() + chrono::Duration::seconds(30),
        };

        Ok(quote)
    }

    /// Health check
    pub async fn health_check(&self) -> Result<bool> {
        match self.client
            .get(&format!("{}/health", self.base_url))
            .send()
            .await
        {
            Ok(response) => Ok(response.status().is_success()),
            Err(e) => {
                warn!("Health check failed: {}", e);
                Ok(false)
            }
        }
    }

    /// Set cache duration
    pub fn set_cache_duration(&mut self, duration: std::time::Duration) {
        self.cache_duration = duration;
    }

    /// Clear cache
    pub fn clear_cache(&mut self) {
        self.cache.clear();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_api_client_creation() {
        let client = ApiClient::new("https://api.example.com");
        assert!(client.is_ok());
    }

    #[tokio::test]
    async fn test_get_jupiter_pools() {
        let client = ApiClient::new("https://api.example.com").unwrap();
        let pools = client.get_jupiter_pools().await;
        assert!(pools.is_ok());
        
        let pools = pools.unwrap();
        assert!(!pools.is_empty());
    }
}
