use crate::{
    error::{LiquidityError, Result},
    types::{SwapRequest, SwapResult, TradeRoute, Pool, SwapQuote},
    solana_client::SolanaClient,
    api_client::ApiClient,
    security::SecurityManager,
};
use std::collections::HashMap;
use log::{info, warn, error};

pub struct LiquidityEngine {
    api_client: ApiClient,
    solana_client: SolanaClient,
    security_manager: std::cell::RefCell<SecurityManager>,
    pools_cache: HashMap<String, Pool>,
    routes_cache: HashMap<String, Vec<TradeRoute>>,
}

impl LiquidityEngine {
    pub fn new(
        api_client: ApiClient,
        solana_client: SolanaClient,
        security_manager: SecurityManager,
    ) -> Result<Self> {
        Ok(Self {
            api_client,
            solana_client,
            security_manager: std::cell::RefCell::new(security_manager),
            pools_cache: HashMap::new(),
            routes_cache: HashMap::new(),
        })
    }

    /// Find the best route for a swap
    pub async fn find_best_route(&mut self, swap_request: &SwapRequest) -> Result<Option<TradeRoute>> {
        info!("Finding best route for {} -> {} (amount: {})", 
            swap_request.input_token, 
            swap_request.output_token, 
            swap_request.amount
        );

        // Security check
        self.security_manager.borrow_mut().validate_swap_request(swap_request)?;

        // Get available pools
        let pools = self.get_available_pools().await?;
        
        // Find routes
        let routes = self.find_routes(&swap_request.input_token, &swap_request.output_token, &pools)?;
        
        if routes.is_empty() {
            return Ok(None);
        }

        // Calculate best route
        let best_route = self.calculate_best_route(routes, swap_request)?;
        
        Ok(Some(best_route))
    }

    /// Execute a swap using the provided route
    pub async fn execute_swap(&self, route: &TradeRoute) -> Result<SwapResult> {
        info!("Executing swap with route: {:?}", route);

        // Security validation
        self.security_manager.borrow_mut().validate_route(route)?;

        // Execute the swap on Solana
        let swap_result = self.solana_client.execute_swap(
            &SwapRequest {
                input_token: route.input_token.clone(),
                output_token: route.output_token.clone(),
                amount: route.expected_output,
                slippage_tolerance: 0.5, // Default 0.5%
            },
            route
        ).await?;

        info!("Swap executed successfully: {}", swap_result.transaction_id);
        Ok(swap_result)
    }

    /// Get quote for a swap
    pub async fn get_quote(&self, swap_request: &SwapRequest) -> Result<SwapQuote> {
        info!("Getting quote for swap: {:?}", swap_request);

        // Security check
        self.security_manager.borrow_mut().validate_swap_request(swap_request)?;

        // Get quote from API
        let quote = self.api_client.get_swap_quote(
            &swap_request.input_token,
            &swap_request.output_token,
            swap_request.amount,
            swap_request.slippage_tolerance,
        ).await?;

        Ok(quote)
    }

    /// Get available pools
    async fn get_available_pools(&mut self) -> Result<Vec<Pool>> {
        // Try to get from cache first
        if !self.pools_cache.is_empty() {
            return Ok(self.pools_cache.values().cloned().collect());
        }

        // Fetch from API
        let pools = self.api_client.get_jupiter_pools().await?;
        
        // Cache the pools
        for pool in &pools {
            self.pools_cache.insert(pool.address.clone(), pool.clone());
        }

        Ok(pools)
    }

    /// Find possible routes between two tokens
    fn find_routes(
        &self,
        input_token: &str,
        output_token: &str,
        pools: &[Pool],
    ) -> Result<Vec<TradeRoute>> {
        let mut routes = Vec::new();

        // Direct routes
        for pool in pools {
            if (pool.token_a == input_token && pool.token_b == output_token) ||
               (pool.token_a == output_token && pool.token_b == input_token) {
                routes.push(TradeRoute {
                    pools: vec![pool.clone()],
                    input_token: input_token.to_string(),
                    output_token: output_token.to_string(),
                    expected_output: self.calculate_output_amount(pool, input_token, output_token)?,
                    fee_estimate: self.calculate_fee(pool)?,
                    price_impact: self.calculate_price_impact(pool)?,
                    route_type: crate::types::RouteType::Direct,
                });
            }
        }

        // Multi-hop routes (simplified - in real implementation, you'd find all possible paths)
        // For now, we'll just return direct routes
        Ok(routes)
    }

    /// Calculate the best route based on various factors
    fn calculate_best_route(
        &self,
        routes: Vec<TradeRoute>,
        swap_request: &SwapRequest,
    ) -> Result<TradeRoute> {
        if routes.is_empty() {
            return Err(LiquidityError::NoRouteFound {
                input_token: swap_request.input_token.clone(),
                output_token: swap_request.output_token.clone(),
            });
        }

        // Simple selection: choose the route with highest expected output
        let best_route = routes
            .into_iter()
            .max_by_key(|route| route.expected_output)
            .unwrap();

        Ok(best_route)
    }

    /// Calculate output amount for a swap
    fn calculate_output_amount(
        &self,
        pool: &Pool,
        input_token: &str,
        output_token: &str,
    ) -> Result<u64> {
        // Simple constant product formula (x * y = k)
        // In real implementation, you'd use the actual DEX formula
        
        let (reserve_in, reserve_out) = if pool.token_a == input_token {
            (pool.reserve_a, pool.reserve_b)
        } else {
            (pool.reserve_b, pool.reserve_a)
        };

        // Calculate output amount (simplified)
        let fee_multiplier = 1.0 - pool.fee_rate;
        let output_amount = (reserve_out as f64 * fee_multiplier) as u64;
        
        Ok(output_amount)
    }

    /// Calculate fee for a swap
    fn calculate_fee(&self, pool: &Pool) -> Result<u64> {
        // Calculate fee based on pool fee rate
        let fee = (pool.reserve_a as f64 * pool.fee_rate) as u64;
        Ok(fee)
    }

    /// Calculate price impact
    fn calculate_price_impact(&self, pool: &Pool) -> Result<f64> {
        // Calculate price impact (simplified)
        let impact = pool.fee_rate * 100.0; // Convert to percentage
        Ok(impact)
    }

    /// Get pool information
    pub async fn get_pool_info(&mut self, pool_address: &str) -> Result<Pool> {
        if let Some(pool) = self.pools_cache.get(pool_address) {
            return Ok(pool.clone());
        }

        // Fetch from blockchain
        let pool = self.solana_client.get_pool_info(pool_address).await?;
        
        // Cache the result
        self.pools_cache.insert(pool_address.to_string(), pool.clone());
        
        Ok(pool)
    }

    /// Clear cache
    pub fn clear_cache(&mut self) {
        self.pools_cache.clear();
        self.routes_cache.clear();
    }
}
