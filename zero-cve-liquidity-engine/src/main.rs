use zero_cve_liquidity_engine::{
    liquidity_engine::LiquidityEngine,
    solana_client::SolanaClient,
    api_client::ApiClient,
    security::SecurityManager,
    types::{SwapRequest, SwapResult, Pool, TradeRoute},
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging
    env_logger::init();
    log::info!("üöÄ Starting Zero-CVE Liquidity Engine");

    // Initialize components
    let api_client = ApiClient::new("https://api.mainnet-beta.solana.com")?;
    let solana_client = SolanaClient::new("https://api.mainnet-beta.solana.com")?;
    let security_manager = SecurityManager::new()?;
    
    let mut liquidity_engine = LiquidityEngine::new(
        api_client,
        solana_client,
        security_manager,
    )?;

    // Example: Find best route for USDC to SOL swap
    let swap_request = SwapRequest {
        input_token: "USDC".to_string(),
        output_token: "SOL".to_string(),
        amount: 100_000_000, // 100 USDC (6 decimals)
        slippage_tolerance: 0.5, // 0.5%
    };

    match liquidity_engine.find_best_route(&swap_request).await {
        Ok(Some(route)) => {
            log::info!("‚úÖ Found optimal route: {:?}", route);
            
            // Execute the swap
            match liquidity_engine.execute_swap(&route).await {
                Ok(result) => {
                    log::info!("‚úÖ Swap executed successfully: {:?}", result);
                }
                Err(e) => {
                    log::error!("‚ùå Swap execution failed: {}", e);
                }
            }
        }
        Ok(None) => {
            log::warn!("‚ö†Ô∏è No route found for the requested swap");
        }
        Err(e) => {
            log::error!("‚ùå Error finding route: {}", e);
        }
    }

    Ok(())
}
