use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    pubkey::Pubkey,
    signature::{Keypair, Signature, Signer},
    transaction::Transaction,
    instruction::Instruction,
};
use solana_program::{
    instruction::AccountMeta,
};
use crate::{
    error::{LiquidityError, Result},
    types::{SwapRequest, SwapResult, Pool},
};
use std::collections::HashMap;
use log::{info, warn, error};

pub struct SolanaClient {
    client: RpcClient,
    keypair: Option<Keypair>,
    pools_cache: HashMap<String, Pool>,
    last_cache_update: std::time::Instant,
}

impl SolanaClient {
    pub fn new(rpc_url: &str) -> Result<Self> {
        let client = RpcClient::new_with_commitment(
            rpc_url.to_string(),
            CommitmentConfig::confirmed(),
        );
        
        Ok(Self {
            client,
            keypair: None,
            pools_cache: HashMap::new(),
            last_cache_update: std::time::Instant::now(),
        })
    }

    pub fn with_keypair(mut self, keypair: Keypair) -> Self {
        self.keypair = Some(keypair);
        self
    }

    /// Get account balance
    pub async fn get_balance(&self, pubkey: &Pubkey) -> Result<u64> {
        self.client
            .get_balance(pubkey)
            .map_err(LiquidityError::SolanaError)
    }

    /// Get token account balance
    pub async fn get_token_account_balance(&self, token_account: &Pubkey) -> Result<u64> {
        let balance = self.client
            .get_token_account_balance(token_account)
            .map_err(LiquidityError::SolanaError)?;
        
        Ok(balance.ui_amount.unwrap_or(0.0) as u64)
    }

    /// Send transaction
    pub async fn send_transaction(&self, transaction: Transaction) -> Result<Signature> {
        if let Some(ref keypair) = self.keypair {
            let signature = self.client
                .send_and_confirm_transaction_with_spinner_and_commitment(
                    &transaction,
                    CommitmentConfig::confirmed(),
                )
                .map_err(LiquidityError::SolanaError)?;
            
            info!("Transaction sent successfully: {}", signature);
            Ok(signature)
        } else {
            Err(LiquidityError::ConfigurationError {
                message: "No keypair configured".to_string(),
            })
        }
    }

    /// Get pool information
    pub async fn get_pool_info(&mut self, pool_address: &str) -> Result<Pool> {
        // Check cache first
        if let Some(pool) = self.pools_cache.get(pool_address) {
            return Ok(pool.clone());
        }

        // Fetch from blockchain
        let pool_address_pubkey = pool_address
            .parse::<Pubkey>()
            .map_err(|_| LiquidityError::InvalidTokenAddress {
                address: pool_address.to_string(),
            })?;

        let account_info = self.client
            .get_account(&pool_address_pubkey)
            .map_err(LiquidityError::SolanaError)?;

        // Parse pool data (simplified - in real implementation, you'd parse the actual pool structure)
        let pool = Pool {
            address: pool_address.to_string(),
            token_a: "USDC".to_string(), // Placeholder
            token_b: "SOL".to_string(),  // Placeholder
            reserve_a: 1000000000,       // Placeholder
            reserve_b: 1000000000,       // Placeholder
            fee_rate: 0.003,             // 0.3%
            volume_24h: 1000000000,      // Placeholder
            liquidity: 1000000000,       // Placeholder
        };

        // Cache the result
        self.pools_cache.insert(pool_address.to_string(), pool.clone());
        
        Ok(pool)
    }

    /// Get multiple pools
    pub async fn get_pools(&mut self, pool_addresses: &[String]) -> Result<Vec<Pool>> {
        let mut pools = Vec::new();
        
        for address in pool_addresses {
            match self.get_pool_info(address).await {
                Ok(pool) => pools.push(pool),
                Err(e) => {
                    warn!("Failed to get pool {}: {}", address, e);
                    continue;
                }
            }
        }
        
        Ok(pools)
    }

    /// Create swap instruction
    pub fn create_swap_instruction(
        &self,
        swap_request: &SwapRequest,
        pool_address: &Pubkey,
        user_token_account: &Pubkey,
        pool_token_account: &Pubkey,
    ) -> Result<Instruction> {
        // This is a simplified swap instruction
        // In a real implementation, you'd create the actual swap instruction for the specific DEX
        
        let accounts = vec![
            AccountMeta::new(*pool_address, false),
            AccountMeta::new(*user_token_account, false),
            AccountMeta::new(*pool_token_account, false),
        ];

        let data = vec![
            0x01, // Instruction discriminator for swap
            // Add more instruction data as needed
        ];

        Ok(Instruction {
            program_id: *pool_address, // This should be the actual program ID
            accounts,
            data,
        })
    }

    /// Execute swap transaction
    pub async fn execute_swap(&self, swap_request: &SwapRequest, route: &crate::types::TradeRoute) -> Result<SwapResult> {
        if self.keypair.is_none() {
            return Err(LiquidityError::ConfigurationError {
                message: "No keypair configured for transaction".to_string(),
            });
        }

        // Create transaction
        let mut transaction = Transaction::new_with_payer(
            &[], // Instructions will be added
            Some(&self.keypair.as_ref().unwrap().pubkey()),
        );

        // Add swap instructions for each pool in the route
        for pool in &route.pools {
            let instruction = self.create_swap_instruction(
                swap_request,
                &pool.address.parse().unwrap(),
                &self.keypair.as_ref().unwrap().pubkey(),
                &self.keypair.as_ref().unwrap().pubkey(), // This should be the actual pool token account
            )?;
            
            // Convert Instruction to CompiledInstruction
            let compiled_instruction = solana_sdk::instruction::CompiledInstruction {
                program_id_index: 0, // This should be the actual program ID index
                accounts: instruction.accounts.iter().map(|acc| 0).collect(), // Simplified
                data: instruction.data,
            };
            
            transaction.message.instructions.push(compiled_instruction);
        }

        // Send transaction
        let signature = self.send_transaction(transaction).await?;

        // Create swap result
        let swap_result = SwapResult {
            transaction_id: signature.to_string(),
            input_amount: swap_request.amount,
            output_amount: route.expected_output,
            fee_amount: route.fee_estimate,
            route_used: route.clone(),
            timestamp: chrono::Utc::now(),
            success: true,
        };

        Ok(swap_result)
    }

    /// Get recent blockhash
    pub async fn get_recent_blockhash(&self) -> Result<solana_sdk::hash::Hash> {
        self.client
            .get_latest_blockhash()
            .map_err(LiquidityError::SolanaError)
    }

    /// Validate transaction
    pub async fn validate_transaction(&self, signature: &Signature) -> Result<bool> {
        match self.client.confirm_transaction(signature) {
            Ok(confirmed) => Ok(confirmed),
            Err(e) => {
                error!("Transaction validation failed: {}", e);
                Ok(false)
            }
        }
    }
}
