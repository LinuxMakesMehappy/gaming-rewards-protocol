use serde::{Deserialize, Serialize};
use rust_decimal::Decimal;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapRequest {
    pub input_token: String,
    pub output_token: String,
    pub amount: u64,
    pub slippage_tolerance: f64, // percentage
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapResult {
    pub transaction_id: String,
    pub input_amount: u64,
    pub output_amount: u64,
    pub fee_amount: u64,
    pub route_used: TradeRoute,
    pub timestamp: DateTime<Utc>,
    pub success: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Pool {
    pub address: String,
    pub token_a: String,
    pub token_b: String,
    pub reserve_a: u64,
    pub reserve_b: u64,
    pub fee_rate: f64,
    pub volume_24h: u64,
    pub liquidity: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeRoute {
    pub pools: Vec<Pool>,
    pub input_token: String,
    pub output_token: String,
    pub expected_output: u64,
    pub fee_estimate: u64,
    pub price_impact: f64,
    pub route_type: RouteType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RouteType {
    Direct,
    MultiHop,
    Split,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenInfo {
    pub symbol: String,
    pub address: String,
    pub decimals: u8,
    pub price_usd: Option<Decimal>,
    pub volume_24h: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LiquidityPool {
    pub id: String,
    pub token_a: TokenInfo,
    pub token_b: TokenInfo,
    pub reserve_a: u64,
    pub reserve_b: u64,
    pub fee_rate: f64,
    pub total_supply: u64,
    pub volume_24h: u64,
    pub tvl_usd: Option<Decimal>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketData {
    pub token: String,
    pub price_usd: Decimal,
    pub volume_24h: u64,
    pub market_cap: Option<u64>,
    pub price_change_24h: f64,
    pub last_updated: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapQuote {
    pub input_token: String,
    pub output_token: String,
    pub input_amount: u64,
    pub output_amount: u64,
    pub fee_amount: u64,
    pub price_impact: f64,
    pub route: TradeRoute,
    pub valid_until: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityContext {
    pub user_id: String,
    pub session_id: String,
    pub risk_level: RiskLevel,
    pub rate_limit_remaining: u32,
    pub last_action: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RiskLevel {
    Low,
    Medium,
    High,
    Critical,
}

impl PartialEq for RiskLevel {
    fn eq(&self, other: &Self) -> bool {
        std::mem::discriminant(self) == std::mem::discriminant(other)
    }
}
